________________________________________
üìò Project Report: 2Cuz Chatbot
________________________________________
1. Cover Page
‚Ä¢	Title: 2Cuz Chatbot
‚Ä¢	Course: Artificial Intelligence and Machine Learning ‚Äì First Semester
‚Ä¢	Submitted by: [Mohammad Faiz Khan]
‚Ä¢	Roll Number: [25BSA10045]
________________________________________
2. Introduction
This is a simple chatbot I made using 2 of my cousins(Hiba for Hibatron Rosheen for Rosh2D2 ), by recording their responses and using those as the answers of the chatbot, Ive put in multiple "out of the ordinary questions" in here and easter eggs that the user can ask and have fun with. Try asking who the strongest bot is, or how to lose weight..
________________________________________
3. Problem Statement
Students in introductory AI/ML courses often need simple projects that demonstrate core concepts without requiring complex algorithms. Traditional chatbot examples can be repetitive or overly advanced. This project solves that by creating a lightweight, creative chatbot that showcases rule based responses, multiple personas, and randomized outputs.
________________________________________
4. Functional Requirements
1.	Accept user input via command line.
2.	Respond to greetings with randomized persona specific replies.
3.	Provide jokes when prompted with the keyword ‚Äújoke.‚Äù
4.	Answer simple queries such as ‚Äúhow are you‚Äù or ‚Äústrongest robot.‚Äù
5.	Offer randomized fallback responses when input does not match any rule.
6.	Exit gracefully when the user types ‚Äúbye.‚Äù
________________________________________
5. Non Functional Requirements
‚Ä¢	Usability: Simple and intuitive for beginners.
‚Ä¢	Reliability: Consistent responses without crashing.
‚Ä¢	Maintainability: Easy to extend with new rules and responses.
‚Ä¢	Performance: Fast response time with minimal resource usage.
‚Ä¢	Portability: Runs on any system with Python 3.x installed.
________________________________________
6. System Architecture
The chatbot follows a simple architecture:
‚Ä¢	Input Layer: Accepts user text input.
‚Ä¢	Processing Layer: Matches input against predefined rules and selects responses.
‚Ä¢	Randomization Module: Chooses a random response from available options.
‚Ä¢	Output Layer: Displays the chatbot‚Äôs reply in the terminal.
(Insert a block diagram here with arrows showing Input ‚Üí Processing ‚Üí Output.)
________________________________________
7. Design Diagrams
7.1 Use Case Diagram
Shows user interacting with chatbot for greetings, jokes, queries, and exit.
7.2 Workflow Diagram
Flowchart: Start ‚Üí User Input ‚Üí Rule Matching ‚Üí Response ‚Üí Loop/Exit.
7.3 Sequence Diagram
User sends input ‚Üí Chatbot processes ‚Üí Chatbot returns response.
7.4 Class/Component Diagram
Single Chatbot class with methods for get_response(), random_choice(), and run().
7.5 ER Diagram (optional if storage used later)
Entity: Response (response_id, category, text).
________________________________________
8. Design Decisions & Rationale
‚Ä¢	Rule based approach: Chosen for simplicity and clarity in a beginner project.
‚Ä¢	Randomization: Adds variety to responses, making the chatbot feel less repetitive.
‚Ä¢	Multiple personas: Enhances engagement and creativity.
‚Ä¢	Text based interface: Keeps the project lightweight and easy to run.
________________________________________
9. Implementation Details
‚Ä¢	Language: Python 3.x
‚Ä¢	Libraries: random for randomized responses
‚Ä¢	Input/Output: Command line interaction
‚Ä¢	Structure: Lists of responses grouped by intent (greeting, joke, fallback, etc.)
________________________________________
10. Screenshots / Results
(Insert screenshots of your chatbot running in the terminal, showing greetings, jokes, fallback responses, and exit message.)
________________________________________
11. Testing Approach
‚Ä¢	Unit Testing: Verified each intent (greeting, joke, query, fallback, exit).
‚Ä¢	Functional Testing: Ensured chatbot responds correctly to expected inputs.
‚Ä¢	Boundary Testing: Checked behavior with unexpected inputs (nonsense text).
‚Ä¢	Exit Testing: Confirmed chatbot terminates correctly when ‚Äúbye‚Äù is entered.
________________________________________
12. Challenges Faced
‚Ä¢	Handling multiple responses without repetition.
‚Ä¢	Ensuring proper indentation and syntax in Python.
‚Ä¢	Managing response lists with commas and formatting.
‚Ä¢	Balancing humor with professionalism in chatbot replies.
________________________________________
13. Learnings & Key Takeaways
‚Ä¢	Gained practical experience in Python programming.
‚Ä¢	Understood rule based AI systems and their limitations.
‚Ä¢	Learned how randomness can improve user experience.
‚Ä¢	Realized the importance of clean code and documentation.
________________________________________
14. Future Enhancements
‚Ä¢	Add audio playback for recorded cousin voices.
‚Ä¢	Integrate NLP libraries (NLTK, spaCy) for smarter text processing.
‚Ä¢	Expand response categories (e.g., facts, riddles, trivia).
‚Ä¢	Create a GUI interface for better user interaction.
‚Ä¢	Store responses in a database for easier management.
________________________________________
15. References
‚Ä¢	Python Documentation: https://docs.python.org/3/
‚Ä¢	TutorialsPoint ‚Äì Python Basics
‚Ä¢	Scikit learn Documentation (for future ML integration): https://scikit-learn.org/
‚Ä¢	UCI Machine Learning Repository (datasets for extended projects)

